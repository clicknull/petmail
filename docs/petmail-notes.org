
Unsorted design notes.

* what does Bob=sigkeyB really mean? what do we want it to mean?
** "Bob" = the other person who knew the shared secret invitation code
** when alice pushes the "send a message to Bob" button:
*** the message can be read by Bob, or by someone he selected
** when alice's agent displays "From: Bob" on a message:
*** Bob must have, at some point, known the contents
*** Bob must have meant to send it to Alice ("the other invitation person")
*** (this is stronger than "someone Bob selected knew the contents")
** each time a new key is exchanged, we must ask: does it maintain these?
** easier to study with simpler models (without PFS, repudiation, pseudonyms)
*** one curve25519 pubkey per user (for both confidentiality and auth)
*** one ed25519 verfkey per user which signs messages and rotating pubkeys
*** verfkey per recip*sender, repudiably signs messages and rotating pubkeys
** if "From: Bob" is based on something signed (as opposed to a pubkey), then
   it should be sufficient to bind the *signing* key to the invitation. 
*** The invitation protocol can end with each side knowing the Ed25519
    verfkey of the other side, and confidentiality-providing pubkeys can be
    delivered later.
*** each message is already bound to the invitation code, by the MAC. We're
    just protecting against Bob using Carol's verfkey instead of his own
*** To create the binding, the invitation process must include a message,
    signed by the sender's signkey, indicating the two ...
*** learn from SIGMA: http://webee.technion.ac.il/~hugo/sigma-pdf.pdf
** start with:
*** A->B: MAC(by=code, tmpA)
*** B->A: MAC(by=code, tmpB), enc(to=tmpA,from=tmpB, verfB+sig(tmpA+tmpB))
*** A->B: enc(to=B,from=A, verfA+sig(tmpA+tmpB))
*** SIGMA-I adds a MAC(by=Km,B) in the second message, and (A) in the third.
    I don't yet understand why, or rather, whether it's sufficient to include
    verfB(A) inside the enc() (which also binds it to the shared key).
    SIGMA-I makes it clear that enc(B+sig) isn't sufficient, and that you
    need three independent keys (MAC key, enc key, session key). Without the
    MAC, it may degenerate into the "Badly Authenticated DH" described in the
    SIGMA paper.
*** add a signed transport record to the 2nd+3rd messages. This will include
    the long-term encryption pubkey, the current rotating pubkeys, and the
    mailbox descriptor. Also MAC() is really symbox().


* forward-secrecy
** basically we need to change the encryption key after each message. The
   recipient gives the sender a new key, the sender uses it until they
   receive the next one (perhaps after a single message, or on some time
   schedule). Sender deliberately forgets the previous key.
** different schemes:
*** Symmetric key. Must be unique to each sender/recipient pair. Both sides
    must hold it until the key rotates. If either side reveals it, all
    messages are compromised. Provides both confidentiality and
    authentication (no other sender knows the key).
*** pair-wise curve25519 keys. Each sender/recipient pair has two keypairs.
    Provides both confidentiality and authentication. Must hold the sending
    key until the other side stops using it to authenticate you, must hold
    the receiving key until the other side stops using it to encrypt to you.
*** recipient curve25519 key, sender ephemeral curve25519 key, sender
    long-term ed25519 key. Each message (or at least the ephemeral sending
    key) is signed to get authenticity. Sender uses new keypair for each
    message, discards privkey as soon as the message is encrypted, minimizing
    exposure window of sender. Recipient switches keys periodically. Sender
    remembers recipient pubkey until notified of the next one. Recipient
    holds privkey until the message has been read and destroyed.
** last one seems most useful
** addressbook entries contain:
*** for outbound messages: "them" section holds next-message curve25519
    public "to" key (replaced when they rotate it), "me" section holds my
    long-term ed25519 signing key (different for each recipient)
*** for inbound messages: "them" section holds their long-term ed25519
    verifying key. "me" section holds current/recent curve25519 private keys
    (discarded when historical messages are destroyed and sender has acked
    rotation)
** note that using different recipient pubkeys over time (per sender) enables
   the mailbox to distinguish senders. Would need an extra layer of wrapping
   to prevent that.
*** mailbox gets box(to=mailbox,from=ephem1,A)
*** A contains box(to=stable-recip, from=ephem2, B)
*** mailbox decrypts A to get B, gives B to recipient
*** B contains box(to=current-recip, from=ephem3, C)
*** recipient decrypts B to get C, C is actual inner message
*** current-recip is rotated. stable-recip is the same for all senders and
    all time, and is used as the client identifier
*** if current-recip is rotated frequently enough, you could get away without
    the extra layer (if every sender+message pair used a different recipient
    key). Seems fragile though.
*** forward security of stable-recip: compromise of that key enables
    mailboxes to distinguish senders.


* repudiation
** general goal is for message recipient to be convinced of the sender, but
   nobody else
** signing message content rules that out
** sending a MAC key in a way that can only be read by the recipient works
** signing an ephmeral pubkey works
*** box(to=recip,from=ephem,msg=(sign(by=sender,msg=ephem)+body))

* message format
** so, to obtain sender-indistinguishability-by-mailbox, forward-security for
   message contents, and sender-repudiability of messages, use this:
** mailbox gets box(to=mailbox,from=ephem1,A)
** A contains box(to=stable-recip, from=ephem2, B)
*** stable-recip is the same for all senders, for all messages, and is the
    client identifier that the mailbox uses to route the message
*** mailbox decrypts A to get B, gives B to recipient
** B contains box(to=current-recip, from=ephem3, C)
*** recipient decrypts B to get C
** C contains sign(by=stable-sender, msg=ephem3) and actual body

* future protocols
** three-layer wrapping protocol
*** protocol:
**** msgD = sign(by=stable-sender, pubkey3) + encoded-payload
**** msgC = encrypt(to=current-recip, from=privkey3, msgD)
**** msgB = encrypt(to=stable-recip, from=privkey2, msgC)
**** msgA = encrypt(to=mailbox, from=privkey1, msgB)
**** mailbox decrypts msgA to get msgB, uses stable-recip as client-id
**** client decrypts msgB to get msgC, then msgD, checks signature.
*** offers:
**** eavesdropper only learns that msgA is aimed at the mailbox host, not
     anything about the recipient or sender
**** mailbox doesn't learn linkability of senders: two messages could be from
     the same sender, or different ones
**** by rotating current-recip, client gets forward secrecy
**** signing pubkey3 (not message) and hiding stable-sender gives deniability
*** criticism:
**** complex: 3 encryption layers, 1 signature, 3 new keypairs, per message
**** outer layer (msgA) is providing transport encryption: using TLS or Tor
     would obviate the need for this one
**** middle layer is to hide sender from mailbox. But:
***** Fast key rotation would do the same (but wouldn't be reliable, requires
      client to be online and respond quickly, or limits sender to one
      message per ack). 
***** Mailbox can probably correlate sender layer 3 address anyways, unless
      using Tor
***** shared connections is another correlation, even with Tor, requiring
      sender to carefully/expensively use new connections for each message
***** relative timing of successive messages is a likely correlation
*** conclusions:
**** defer the middle layer until later. Using Tor, hidden services,
     randomized timing (ala Pond), might make it useful. For v1, don't
     bother.
** two-layer protocol
*** protocol
**** msgC = sign(by=stable-sender, pubkey2) + encoded-payload
**** msgB = client-id + encrypt(to=current-recip, from=privkey2, msgC)
**** msgA = encrypt(to=mailbox, from=privkey1, msgB)
**** mailbox decrypts msgA to get msgB, queues to client-id
**** client decrypts msgB to get msgC, checks signature, delivers payload
*** offers:
**** eavesdropper only learns that msgA is aimed at the mailbox host, not
     anything about the recipient or sender
**** mailbox can link senders
**** by rotating current-recip, client gets forward secrecy
**** signing pubkey2 (not message) and hiding stable-sender gives deniability
** desired unlinkability properties
*** A future version of this protocol should provide the following
    unlinkability properties:
    1. The mailbox cannot distinguish which sender provided a message (from
       the contents of the message.. they still might discern source IP
       address, etc). The mailbox can compute a recipient identifier, to know
       how to route the message, which will the the same no matter which
       sender created it. Two successive messages from the same sender cannot
       be identified as such.
    2. Two senders cannot distinguish whether their transport descriptors
       refer to the same recipient or not, except for the shared mailbox
       addressing information. If Alice and Bob are senders, Carol and Dave
       are two recipients who rent mailboxes from the same host, then Alice
       gets two descriptors AC and AD, and Bob gets BC and BD. When Alice and
       Bob compare their descriptors, they should not be able to distinguish
       whether AC+BC go to the same person, or AC+BD. Alice herself cannot
       tell if AC+AD go to different people or the same person.
    3. The recipient is not required to communicate with the mailbox to add
       each new sender, but can create new descriptors herself.
    4. The sender can produce any number of messages without needing to
       acquire new tokens or information from the recipient.
    5. The mailbox can determine the recipient of a message in constant time,
       rather than iterating through the full list of registered recipients
       looking for a match.
*** I don't yet know of a protocol that can satisfy these conditions. Tthere
    are a number of simpler protocols that provide a subset:
**** Give each sender the (same) client identifier, each sender includes the
     identifier in their message. This provides 1/3/4/5, but not 2. This is
     the current protocol.
**** Register a different client identifier for each sender. Senders include
     the identifier in their message. This provides 2/4/5 but not 1 or 3.
**** Give each sender a big list of single-use tokens, each of which is a
     randomly encrypted copy of the client identifier, using the mailbox's
     public key. This would provide 1/2/3/5 but not 4.
*** I expect a complete protocol would involve the senders getting
    differently-blinded copies of the client identifier, then blinding these
    tokens themselves for each message they send. It may be necessary to
    give up on #5 (mailbox efficiency) to achieve the other four.
** protocol3
*** msgA = enc(to=transport,from=key1,msgB)
*** msgB = recipient-id + enc(to=recip-stable, from=key2, msgC)
**** could merge recipient-id and recip-stable
*** msgC = sender-id + sign(by=sender-stable,key3) + enc(to=recip-current,
    from=key3, body)
**** could merge sender-id and sender-stable
** protocol4
*** msgA = enc(to=transport,from=key1,msgB)
*** msgB = recipient-id + enc(to=recip-stable, from=key2, msgC)
*** msgC = sender-id + enc(to=recip-current, from=key3, msgD)
*** msgD = sign(by=sender-stable,key3) + body
*** key3 could be sender-current instead, remove sender-id, recipient does
    lookup in 2*len(senders) table to find sender id, remove signature in
    msgD. Might interfere with deniability
** protocol5
*** msgA = pubkey1+enc(to=transport,from=key1,msgB)
*** msgB = recipient-id + pubkey2+enc(to=recip-current, from=key2, msgC)
**** recip-current is *not* visible in msgB, only pubkey2, to hide sender
     correlations from server
*** msgC = sign(by=sender-stable,key2) + body
*** recipient does 2*len(senders) trial decryptions of msgB
**** each sender holds a (distinct) single recip-current pubkey, recipient
     remembers the privkey for both previous and next. When recipient sees a
     message encrypted to "next", they rotate (forget "previous", create new
     "next" key, deliver pubkey to sender)
*** msgA hides recipient from eavesdroppers, only useful with shared servers
*** msgB: hides sender from server, provides confidentiality, provides
    forward secrecy against sender compromise (random key2), provides forward
    secrecy against recipient compromise (rotating recip-current).
*** msgC (sig) provides deniable authentication of sender
** protocol6
*** msgA = pubkey1+enc(to=transport,from=key1,msgB)
*** msgB = recip-stable + pubkey2 + enc(to=recip-stable, from=key2, msgC)
*** msgC = sender-stable + sign(by=sender-stable,key3) + pubkey3 + recip-current + enc(to=recip-current, from=key3, msgD)
**** recipient looks up sender-stable in a table, finds two entries
     (previous+new), finds which one matches recip-current, decrypts, maybe
     rotates. No trial decryptions.
*** msgD = body
*** so msgA hides recipient form eavesdroppers
*** msgB hides sender from server
*** msgC provides confidentiality


