
Unsorted design notes.

* forward-secrecy
** basically we need to change the encryption key after each message. The
   recipient gives the sender a new key, the sender uses it until they
   receive the next one (perhaps after a single message, or on some time
   schedule). Sender deliberately forgets the previous key.
** different schemes:
*** Symmetric key. Must be unique to each sender/recipient pair. Both sides
    must hold it until the key rotates. If either side reveals it, all
    messages are compromised. Provides both confidentiality and
    authentication (no other sender knows the key).
*** pair-wise curve25519 keys. Each sender/recipient pair has two keypairs.
    Provides both confidentiality and authentication. Must hold the sending
    key until the other side stops using it to authenticate you, must hold
    the receiving key until the other side stops using it to encrypt to you.
*** recipient curve25519 key, sender ephemeral curve25519 key, sender
    long-term ed25519 key. Each message (or at least the ephemeral sending
    key) is signed to get authenticity. Sender uses new keypair for each
    message, discards privkey as soon as the message is encrypted, minimizing
    exposure window of sender. Recipient switches keys periodically. Sender
    remembers recipient pubkey until notified of the next one. Recipient
    holds privkey until the message has been read and destroyed.
** last one seems most useful
** addressbook entries contain:
*** for outbound messages: "them" section holds next-message curve25519
    public "to" key (replaced when they rotate it), "me" section holds my
    long-term ed25519 signing key (different for each recipient)
*** for inbound messages: "them" section holds their long-term ed25519
    verifying key. "me" section holds current/recent curve25519 private keys
    (discarded when historical messages are destroyed and sender has acked
    rotation)
** note that using different recipient pubkeys over time (per sender) enables
   the mailbox to distinguish senders. Would need an extra layer of wrapping
   to prevent that.
*** mailbox gets box(to=mailbox,from=ephem1,A)
*** A contains box(to=stable-recip, from=ephem2, B)
*** mailbox decrypts A to get B, gives B to recipient
*** B contains box(to=current-recip, from=ephem3, C)
*** recipient decrypts B to get C, C is actual inner message
*** current-recip is rotated. stable-recip is the same for all senders and
    all time, and is used as the client identifier
*** if current-recip is rotated frequently enough, you could get away without
    the extra layer (if every sender+message pair used a different recipient
    key). Seems fragile though.
*** forward security of stable-recip: compromise of that key enables
    mailboxes to distinguish senders.

* repudiation
** general goal is for message recipient to be convinced of the sender, but
   nobody else
** signing message content rules that out
** sending a MAC key in a way that can only be read by the recipient works
** signing an ephmeral pubkey works
*** box(to=recip,from=ephem,msg=(sign(by=sender,msg=ephem)+body))

* message format
** so, to obtain sender-indistinguishability-by-mailbox, forward-security for
   message contents, and sender-repudiability of messages, use this:
** mailbox gets box(to=mailbox,from=ephem1,A)
** A contains box(to=stable-recip, from=ephem2, B)
*** stable-recip is the same for all senders, for all messages, and is the
    client identifier that the mailbox uses to route the message
*** mailbox decrypts A to get B, gives B to recipient
** B contains box(to=current-recip, from=ephem3, C)
*** recipient decrypts B to get C
** C contains sign(by=stable-sender, msg=ephem3) and actual body

* future protocols
** three-layer wrapping protocol
*** protocol:
**** msgD = sign(by=stable-sender, pubkey3) + encoded-payload
**** msgC = encrypt(to=current-recip, from=privkey3, msgD)
**** msgB = encrypt(to=stable-recip, from=privkey2, msgC)
**** msgA = encrypt(to=mailbox, from=privkey1, msgB)
**** mailbox decrypts msgA to get msgB, uses stable-recip as client-id
**** client decrypts msgB to get msgC, then msgD, checks signature.
*** offers:
**** eavesdropper only learns that msgA is aimed at the mailbox host, not
     anything about the recipient or sender
**** mailbox doesn't learn linkability of senders: two messages could be from
     the same sender, or different ones
**** by rotating current-recip, client gets forward secrecy
**** signing pubkey3 (not message) and hiding stable-sender gives deniability
*** criticism:
**** complex: 3 encryption layers, 1 signature, 3 new keypairs, per message
**** outer layer (msgA) is providing transport encryption: using TLS or Tor
     would obviate the need for this one
**** middle layer is to hide sender from mailbox. But:
***** Fast key rotation would do the same (but wouldn't be reliable, requires
      client to be online and respond quickly, or limits sender to one
      message per ack). 
***** Mailbox can probably correlate sender layer 3 address anyways, unless
      using Tor
***** shared connections is another correlation, even with Tor, requiring
      sender to carefully/expensively use new connections for each message
***** relative timing of successive messages is a likely correlation
*** conclusions:
**** defer the middle layer until later. Using Tor, hidden services,
     randomized timing (ala Pond), might make it useful. For v1, don't
     bother.
** two-layer protocol
*** protocol
**** msgC = sign(by=stable-sender, pubkey2) + encoded-payload
**** msgB = client-id + encrypt(to=current-recip, from=privkey2, msgC)
**** msgA = encrypt(to=mailbox, from=privkey1, msgB)
**** mailbox decrypts msgA to get msgB, queues to client-id
**** client decrypts msgB to get msgC, checks signature, delivers payload
*** offers:
**** eavesdropper only learns that msgA is aimed at the mailbox host, not
     anything about the recipient or sender
**** mailbox can link senders
**** by rotating current-recip, client gets forward secrecy
**** signing pubkey2 (not message) and hiding stable-sender gives deniability
** desired unlinkability properties
*** A future version of this protocol should provide the following
    unlinkability properties:
    1. The mailbox cannot distinguish which sender provided a message (from
       the contents of the message.. they still might discern source IP
       address, etc). The mailbox can compute a recipient identifier, to know
       how to route the message, which will the the same no matter which
       sender created it. Two successive messages from the same sender cannot
       be identified as such.
    2. Two senders cannot distinguish whether their transport descriptors
       refer to the same recipient or not, except for the shared mailbox
       addressing information. If Alice and Bob are senders, Carol and Dave
       are two recipients who rent mailboxes from the same host, then Alice
       gets two descriptors AC and AD, and Bob gets BC and BD. When Alice and
       Bob compare their descriptors, they should not be able to distinguish
       whether AC+BC go to the same person, or AC+BD. Alice herself cannot
       tell if AC+AD go to different people or the same person.
    3. The recipient is not required to communicate with the mailbox to add
       each new sender, but can create new descriptors herself.
    4. The sender can produce any number of messages without needing to
       acquire new tokens or information from the recipient.
    5. The mailbox can determine the recipient of a message in constant time,
       rather than iterating through the full list of registered recipients
       looking for a match.
*** I don't yet know of a protocol that can satisfy these conditions. Tthere
    are a number of simpler protocols that provide a subset:
**** Give each sender the (same) client identifier, each sender includes the
     identifier in their message. This provides 1/3/4/5, but not 2. This is
     the current protocol.
**** Register a different client identifier for each sender. Senders include
     the identifier in their message. This provides 2/4/5 but not 1 or 3.
**** Give each sender a big list of single-use tokens, each of which is a
     randomly encrypted copy of the client identifier, using the mailbox's
     public key. This would provide 1/2/3/5 but not 4.
*** I expect a complete protocol would involve the senders getting
    differently-blinded copies of the client identifier, then blinding these
    tokens themselves for each message they send. It may be necessary to
    give up on #5 (mailbox efficiency) to achieve the other four.
